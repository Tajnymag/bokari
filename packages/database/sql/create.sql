BEGIN;

DROP SCHEMA IF EXISTS public CASCADE;
CREATE SCHEMA public;

CREATE OR REPLACE  FUNCTION process_table_changes() RETURNS TRIGGER AS $generic_table_change_trigger$
    BEGIN
        IF (tg_op = 'DELETE') THEN
            EXECUTE format('INSERT INTO %I.%I_changes VALUES (DEFAULT, now(), true, $1.*)', tg_table_schema, tg_table_name)
            USING OLD;
        ELSIF (tg_op = 'UPDATE') THEN
            EXECUTE format('INSERT INTO %I.%I_changes VALUES (DEFAULT, now(), false, $1.*)', tg_table_schema, tg_table_name)
            USING NEW;
        END IF;
            RETURN NULL;
    END
$generic_table_change_trigger$ LANGUAGE plpgsql;

CREATE TABLE people (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name text NOT NULL
);

CREATE TABLE users (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    username text NOT NULL UNIQUE,
    password_hash text NOT NULL,
    person_id integer REFERENCES people(id) NOT NULL
);

CREATE TABLE loggable_table (
    created_by_id integer REFERENCES users(id),
    updated_by_id integer REFERENCES users(id),
    created_at timestamptz DEFAULT now() NOT NULL
);
CREATE TABLE log_table (
    log_id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    updated_at timestamptz DEFAULT now() NOT NULL,
    is_deleted bool DEFAULT false NOT NULL
);

CREATE TABLE businesses (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name text NOT NULL,
    registration_number text NOT NULL
);

CREATE TABLE currencies (
    iso_code text PRIMARY KEY CHECK (length(iso_code) = 3)
);
COMMENT ON COLUMN currencies.iso_code IS 'Code of the currency according to ISO 4217';

CREATE TABLE countries (
    iso_code text PRIMARY KEY CHECK (length(iso_code) = 2)
);
COMMENT ON COLUMN countries.iso_code IS 'Code of the country according to ISO 3166-1 Alpha-2';

CREATE TABLE mime_types (
    name text PRIMARY KEY CHECK (name ~ $$^\w+/\w+\Z$$)
);

CREATE TABLE addresses (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    city text NOT NULL,
    street text NOT NULL,
    state text,
    zip text NOT NULL,
    country_code text REFERENCES countries(iso_code) NOT NULL
);

CREATE TABLE groups (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name text NOT NULL UNIQUE
);

CREATE TABLE permissions (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name text NOT NULL UNIQUE,
    bit smallint NOT NULL CHECK ( bit >= 0 )
);

CREATE TABLE professions (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name text UNIQUE NOT NULL
);

CREATE TABLE clients (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    person_id integer REFERENCES people(id) NOT NULL
);

CREATE TABLE contractors (
    LIKE loggable_table INCLUDING ALL,
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    person_id integer REFERENCES people(id),
    business_id integer REFERENCES businesses(id)
);
CREATE TABLE contractors_changes (
    LIKE log_table INCLUDING ALL,
    LIKE contractors
);
CREATE TRIGGER contractors_changes AFTER UPDATE OR DELETE ON contractors FOR EACH ROW EXECUTE FUNCTION process_table_changes();

CREATE TABLE contacts (
    LIKE loggable_table INCLUDING ALL,
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    email text,
    phone text,
    note text,
    address_id integer REFERENCES addresses(id)
);
CREATE TABLE contacts_changes (
    LIKE log_table INCLUDING ALL,
    LIKE contacts
);
CREATE TRIGGER contacts_changes AFTER UPDATE OR DELETE ON contacts FOR EACH ROW EXECUTE FUNCTION process_table_changes();

CREATE TABLE person_contacts (
    person_id integer REFERENCES people(id),
    contact_id integer REFERENCES contacts(id),
    PRIMARY KEY (person_id, contact_id)
);

CREATE TABLE group_permissions (
    group_id integer REFERENCES groups(id),
    permission_id integer REFERENCES permissions(id),
    PRIMARY KEY (group_id, permission_id)
);

CREATE TABLE group_users (
    user_id integer REFERENCES users(id),
    group_id integer REFERENCES groups(id),
    PRIMARY KEY (user_id, group_id)
);

CREATE TABLE business_professions (
    business_id integer REFERENCES businesses(id),
    profession_id integer REFERENCES professions(id),
    PRIMARY KEY (business_id, profession_id)
);

CREATE TABLE monetary_values (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    amount numeric NOT NULL,
    created_at timestamptz DEFAULT now() NOT NULL,
    currency_code text REFERENCES currencies(iso_code) NOT NULL,
    CONSTRAINT positive_amount CHECK (amount > 0)
);

CREATE TABLE contracts (
    LIKE loggable_table INCLUDING ALL,
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    code text UNIQUE NOT NULL,
    start_at timestamptz DEFAULT now() NOT NULL,
    deadline_at timestamptz NOT NULL,
    name text NOT NULL,
    description text,
    is_done bool DEFAULT false NOT NULL,
    price_id integer REFERENCES monetary_values(id) NOT NULL,
    responsible_user_id integer REFERENCES users(id) NOT NULL,
    client_id integer REFERENCES clients(id) NOT NULL
);
CREATE TABLE contracts_changes (
    LIKE log_table INCLUDING ALL,
    LIKE contracts
);
CREATE TRIGGER contracts_changes AFTER UPDATE OR DELETE ON contracts FOR EACH ROW EXECUTE FUNCTION process_table_changes();

CREATE TABLE expenses (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    description text NOT NULL,
    amount_id integer REFERENCES monetary_values(id) NOT NULL,
    author_id integer REFERENCES users(id) NOT NULL,
    contract_id integer REFERENCES contracts(id)
);

CREATE TABLE comments (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    content text NOT NULL,
    created_at timestamptz DEFAULT now() NOT NULL,
    updated_at timestamptz DEFAULT now() NOT NULL,
    author_id integer REFERENCES users(id) NOT NULL
);

CREATE TABLE files (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name text NOT NULL,
    hash text NOT NULL,
    blurhash text,
    created_at timestamptz DEFAULT now() NOT NULL,
    type text REFERENCES mime_types(name) NOT NULL,
    author_id integer REFERENCES users(id) NOT NULL
);

CREATE TABLE levels (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name text UNIQUE NOT NULL
);

CREATE TABLE contract_levels (
    LIKE loggable_table INCLUDING ALL,
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    contract_id integer REFERENCES contracts(id),
    level_id integer REFERENCES levels(id),
    start_at timestamptz DEFAULT now() NOT NULL,
    deadline_at timestamptz NOT NULL,
    is_done bool DEFAULT false NOT NULL,
    UNIQUE (contract_id, level_id)
);
CREATE TABLE contract_levels_changes (
    LIKE log_table INCLUDING ALL,
    LIKE contract_levels
);
CREATE TRIGGER contract_levels_changes AFTER UPDATE OR DELETE ON contract_levels FOR EACH ROW EXECUTE FUNCTION process_table_changes();

CREATE TABLE subcontracts (
    LIKE loggable_table INCLUDING ALL,
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    start_at timestamptz DEFAULT now() NOT NULL,
    deadline_at timestamptz NOT NULL,
    name text,
    description text,
    is_done bool DEFAULT false NOT NULL,
    price_id integer REFERENCES monetary_values(id) NOT NULL,
    contractor_id integer REFERENCES contractors(id) NOT NULL
);
CREATE TABLE subcontracts_changes (
    LIKE log_table INCLUDING ALL,
    LIKE subcontracts
);
CREATE TRIGGER subcontracts_changes AFTER UPDATE OR DELETE ON subcontracts FOR EACH ROW EXECUTE FUNCTION process_table_changes();

CREATE TABLE subcontract_levels (
    LIKE loggable_table INCLUDING ALL,
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    contract_level_id integer REFERENCES contract_levels(id),
    subcontract_id integer REFERENCES subcontracts(id),
    UNIQUE (contract_level_id, subcontract_id)
);
CREATE TABLE subcontract_levels_changes (
    LIKE log_table INCLUDING ALL,
    LIKE subcontract_levels
);
CREATE TRIGGER subcontract_levels_changes AFTER UPDATE OR DELETE ON subcontract_levels FOR EACH ROW EXECUTE FUNCTION process_table_changes();

CREATE TABLE contract_files (
    LIKE loggable_table INCLUDING ALL,
    contract_id integer REFERENCES contracts(id),
    file_id integer REFERENCES files(id),
    PRIMARY KEY (contract_id, file_id)
);
CREATE TABLE contract_files_changes (
    LIKE log_table INCLUDING ALL,
    LIKE contract_files
);
CREATE TRIGGER contract_files_changes AFTER UPDATE OR DELETE ON contract_files FOR EACH ROW EXECUTE FUNCTION process_table_changes();

CREATE TABLE subcontract_files (
    LIKE loggable_table INCLUDING ALL,
    subcontract_id integer REFERENCES subcontracts(id),
    file_id integer REFERENCES files(id),
    PRIMARY KEY (subcontract_id, file_id)
);
CREATE TABLE subcontract_files_changes (
    LIKE log_table INCLUDING ALL,
    LIKE subcontract_files
);
CREATE TRIGGER subcontract_files_changes AFTER UPDATE OR DELETE ON subcontract_files FOR EACH ROW EXECUTE FUNCTION process_table_changes();

CREATE TABLE contract_comments (
    contract_id integer REFERENCES contracts(id),
    comment_id integer REFERENCES comments(id),
    PRIMARY KEY (contract_id, comment_id)
);

CREATE TABLE subcontract_comments (
    subcontract_id integer REFERENCES subcontracts(id),
    comment_id integer REFERENCES comments(id),
    PRIMARY KEY (subcontract_id, comment_id)
);

CREATE TABLE work_logs (
    LIKE loggable_table INCLUDING ALL,
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    started_at timestamptz NOT NULL,
    ended_at timestamptz NOT NULL,
    contract_id integer REFERENCES contracts(id),
    CONSTRAINT ended_after_started CHECK (started_at < ended_at)
);
CREATE TABLE work_logs_changes (
    LIKE log_table INCLUDING ALL,
    LIKE work_logs
);
CREATE TRIGGER work_logs_changes AFTER UPDATE OR DELETE ON work_logs FOR EACH ROW EXECUTE FUNCTION process_table_changes();

CREATE TABLE wages (
    LIKE loggable_table INCLUDING ALL,
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    wage_id integer REFERENCES monetary_values(id) NOT NULL,
    employee_id integer REFERENCES users(id) NOT NULL
);+

CREATE TABLE refresh_tokens (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    token text NOT NULL,
    user_id integer REFERENCES users(id) NOT NULL,
    created_at timestamptz DEFAULT now() NOT NULL
);

COMMIT;
