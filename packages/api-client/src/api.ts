import { Currency } from "@bokari/entities"
import { Permission as Permissions } from "@bokari/entities"
/* tslint:disable */
/* eslint-disable */
/**
 * Bokari REST API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccessTokenPayload
 */
export interface AccessTokenPayload {
    /**
     * 
     * @type {string}
     * @memberof AccessTokenPayload
     */
    type: Type;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccessTokenPayload
     */
    scopes?: Array<Scopes>;
    /**
     * 
     * @type {User}
     * @memberof AccessTokenPayload
     */
    user: User;
    /**
     * 
     * @type {number}
     * @memberof AccessTokenPayload
     */
    iat?: number;
    /**
     * 
     * @type {number}
     * @memberof AccessTokenPayload
     */
    exp?: number;
}


/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {number}
     * @memberof Address
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    street: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    zip: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    country: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    state?: string;
}
/**
 * 
 * @export
 * @interface AddressInsertable
 */
export interface AddressInsertable {
    /**
     * 
     * @type {string}
     * @memberof AddressInsertable
     */
    street: string;
    /**
     * 
     * @type {string}
     * @memberof AddressInsertable
     */
    zip: string;
    /**
     * 
     * @type {string}
     * @memberof AddressInsertable
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof AddressInsertable
     */
    country: string;
    /**
     * 
     * @type {string}
     * @memberof AddressInsertable
     */
    state?: string;
}
/**
 * 
 * @export
 * @interface Contact
 */
export interface Contact {
    /**
     * 
     * @type {number}
     * @memberof Contact
     */
    id: number;
    /**
     * 
     * @type {Address}
     * @memberof Contact
     */
    address?: Address;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    phone: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    note: string;
}
/**
 * 
 * @export
 * @interface ContactInsertable
 */
export interface ContactInsertable {
    /**
     * 
     * @type {AddressInsertable}
     * @memberof ContactInsertable
     */
    address?: AddressInsertable;
    /**
     * 
     * @type {string}
     * @memberof ContactInsertable
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactInsertable
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactInsertable
     */
    note?: string;
}
/**
 * 
 * @export
 * @interface ContactUpdatable
 */
export interface ContactUpdatable {
    /**
     * 
     * @type {AddressInsertable}
     * @memberof ContactUpdatable
     */
    address?: AddressInsertable;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdatable
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdatable
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdatable
     */
    note?: string;
}
/**
 * 
 * @export
 * @interface Contract
 */
export interface Contract {
    /**
     * 
     * @type {number}
     * @memberof Contract
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    startAt: string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    deadlineAt: string;
    /**
     * 
     * @type {boolean}
     * @memberof Contract
     */
    isDone: boolean;
    /**
     * 
     * @type {Metadata}
     * @memberof Contract
     */
    metadata: Metadata;
    /**
     * 
     * @type {Customer}
     * @memberof Contract
     */
    customer: Customer;
    /**
     * 
     * @type {Monetary}
     * @memberof Contract
     */
    price: Monetary;
    /**
     * 
     * @type {Array<ContractAttachment>}
     * @memberof Contract
     */
    attachments: Array<ContractAttachment>;
    /**
     * 
     * @type {Array<WorkLog>}
     * @memberof Contract
     */
    workLogs: Array<WorkLog>;
    /**
     * 
     * @type {Array<ContractPhase>}
     * @memberof Contract
     */
    contractPhases: Array<ContractPhase>;
}
/**
 * 
 * @export
 * @interface ContractAttachment
 */
export interface ContractAttachment {
    /**
     * 
     * @type {number}
     * @memberof ContractAttachment
     */
    id: number;
    /**
     * 
     * @type {any}
     * @memberof ContractAttachment
     */
    file: any;
    /**
     * 
     * @type {string}
     * @memberof ContractAttachment
     */
    note: string;
    /**
     * 
     * @type {Metadata}
     * @memberof ContractAttachment
     */
    metadata: Metadata;
}
/**
 * 
 * @export
 * @interface ContractAttachmentInsertable
 */
export interface ContractAttachmentInsertable {
    /**
     * 
     * @type {FileJoinable}
     * @memberof ContractAttachmentInsertable
     */
    file: FileJoinable;
    /**
     * 
     * @type {string}
     * @memberof ContractAttachmentInsertable
     */
    note?: string;
}
/**
 * 
 * @export
 * @interface ContractInsertable
 */
export interface ContractInsertable {
    /**
     * 
     * @type {string}
     * @memberof ContractInsertable
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof ContractInsertable
     */
    name: string;
    /**
     * 
     * @type {CustomerJoinable}
     * @memberof ContractInsertable
     */
    customer: CustomerJoinable;
    /**
     * 
     * @type {string}
     * @memberof ContractInsertable
     */
    startAt: string;
    /**
     * 
     * @type {string}
     * @memberof ContractInsertable
     */
    deadlineAt: string;
    /**
     * 
     * @type {string}
     * @memberof ContractInsertable
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ContractInsertable
     */
    isDone?: boolean;
    /**
     * 
     * @type {Monetary}
     * @memberof ContractInsertable
     */
    price: Monetary;
}
/**
 * 
 * @export
 * @interface ContractJoinable
 */
export interface ContractJoinable {
    /**
     * 
     * @type {number}
     * @memberof ContractJoinable
     */
    id: number;
}
/**
 * 
 * @export
 * @interface ContractPhase
 */
export interface ContractPhase {
    /**
     * 
     * @type {string}
     * @memberof ContractPhase
     */
    deadlineAt: string;
    /**
     * 
     * @type {boolean}
     * @memberof ContractPhase
     */
    isDone: boolean;
    /**
     * 
     * @type {Phase}
     * @memberof ContractPhase
     */
    phase: Phase;
}
/**
 * 
 * @export
 * @interface ContractPhaseInsertable
 */
export interface ContractPhaseInsertable {
    /**
     * 
     * @type {string}
     * @memberof ContractPhaseInsertable
     */
    deadlineAt: string;
    /**
     * 
     * @type {boolean}
     * @memberof ContractPhaseInsertable
     */
    isDone: boolean;
    /**
     * 
     * @type {number}
     * @memberof ContractPhaseInsertable
     */
    phaseId: number;
}
/**
 * 
 * @export
 * @interface ContractUpdatable
 */
export interface ContractUpdatable {
    /**
     * 
     * @type {any}
     * @memberof ContractUpdatable
     */
    code?: any | null;
    /**
     * 
     * @type {any}
     * @memberof ContractUpdatable
     */
    name?: any | null;
    /**
     * 
     * @type {any}
     * @memberof ContractUpdatable
     */
    startAt?: any | null;
    /**
     * 
     * @type {any}
     * @memberof ContractUpdatable
     */
    deadlineAt?: any | null;
    /**
     * 
     * @type {any}
     * @memberof ContractUpdatable
     */
    customer?: any | null;
    /**
     * 
     * @type {any}
     * @memberof ContractUpdatable
     */
    price?: any | null;
}
/**
 * 
 * @export
 * @interface ContractsQueryFilterable
 */
export interface ContractsQueryFilterable {
    /**
     * 
     * @type {string}
     * @memberof ContractsQueryFilterable
     */
    deadlineAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ContractsQueryFilterable
     */
    startAt?: string;
}
/**
 * 
 * @export
 * @interface ContractsQueryParams
 */
export interface ContractsQueryParams {
    /**
     * 
     * @type {number}
     * @memberof ContractsQueryParams
     */
    limit?: number;
    /**
     * 
     * @type {number}
     * @memberof ContractsQueryParams
     */
    page?: number;
    /**
     * 
     * @type {string}
     * @memberof ContractsQueryParams
     */
    search?: string;
    /**
     * 
     * @type {string}
     * @memberof ContractsQueryParams
     */
    orderBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ContractsQueryParams
     */
    order?: Order;
    /**
     * 
     * @type {ContractsQueryFilterable}
     * @memberof ContractsQueryParams
     */
    filterMax?: ContractsQueryFilterable;
    /**
     * 
     * @type {ContractsQueryFilterable}
     * @memberof ContractsQueryParams
     */
    filterMin?: ContractsQueryFilterable;
}

/**
    * @export
    * @enum {string}
    */
export enum Order {
    ASC = 'ASC',
    DESC = 'DESC'
}

/**
 * 
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * 
     * @type {number}
     * @memberof Customer
     */
    id: number;
    /**
     * 
     * @type {Person}
     * @memberof Customer
     */
    person: Person;
}
/**
 * 
 * @export
 * @interface CustomerInsertable
 */
export interface CustomerInsertable {
    /**
     * 
     * @type {PersonInsertable}
     * @memberof CustomerInsertable
     */
    person: PersonInsertable;
}
/**
 * 
 * @export
 * @interface CustomerJoinable
 */
export interface CustomerJoinable {
    /**
     * 
     * @type {number}
     * @memberof CustomerJoinable
     */
    id: number;
}
/**
 * 
 * @export
 * @interface FileJoinable
 */
export interface FileJoinable {
    /**
     * 
     * @type {number}
     * @memberof FileJoinable
     */
    id: number;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    name: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Group
     */
    permissions: Array<Permissions>;
    /**
     * 
     * @type {Array<User>}
     * @memberof Group
     */
    users: Array<User>;
}


/**
 * 
 * @export
 * @interface GroupInsertable
 */
export interface GroupInsertable {
    /**
     * 
     * @type {string}
     * @memberof GroupInsertable
     */
    name: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupInsertable
     */
    permissions: Array<Permissions>;
    /**
     * 
     * @type {Array<UserJoinable>}
     * @memberof GroupInsertable
     */
    users: Array<UserJoinable>;
}


/**
 * 
 * @export
 * @interface GroupJoinable
 */
export interface GroupJoinable {
    /**
     * 
     * @type {number}
     * @memberof GroupJoinable
     */
    id: number;
}
/**
 * 
 * @export
 * @interface GroupUpdatable
 */
export interface GroupUpdatable {
    /**
     * 
     * @type {string}
     * @memberof GroupUpdatable
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupUpdatable
     */
    permissions?: Array<Permissions>;
    /**
     * 
     * @type {Array<UserJoinable>}
     * @memberof GroupUpdatable
     */
    users?: Array<UserJoinable>;
}


/**
 * 
 * @export
 * @interface JwtPayload
 */
export interface JwtPayload {
    /**
     * 
     * @type {string}
     * @memberof JwtPayload
     */
    type: Type;
    /**
     * 
     * @type {User}
     * @memberof JwtPayload
     */
    user: User;
    /**
     * 
     * @type {number}
     * @memberof JwtPayload
     */
    iat?: number;
    /**
     * 
     * @type {number}
     * @memberof JwtPayload
     */
    exp?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof JwtPayload
     */
    scopes?: Array<Scopes>;
}


/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    password: string;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    accessToken: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    refreshToken: string;
}
/**
 * 
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    updatedAt: string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    deletedAt: string;
    /**
     * 
     * @type {User}
     * @memberof Metadata
     */
    createdBy: User;
}
/**
 * 
 * @export
 * @interface ModelFile
 */
export interface ModelFile {
    /**
     * 
     * @type {number}
     * @memberof ModelFile
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    hash: string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    filename: string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    mimeType: string;
    /**
     * 
     * @type {Metadata}
     * @memberof ModelFile
     */
    metadata: Metadata;
}
/**
 * 
 * @export
 * @interface Monetary
 */
export interface Monetary {
    /**
     * 
     * @type {number}
     * @memberof Monetary
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof Monetary
     */
    currency: Currency;
}


/**
 * 
 * @export
 * @interface Person
 */
export interface Person {
    /**
     * 
     * @type {number}
     * @memberof Person
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    name: string;
    /**
     * 
     * @type {Array<Contact>}
     * @memberof Person
     */
    contacts: Array<Contact>;
}
/**
 * 
 * @export
 * @interface PersonInsertable
 */
export interface PersonInsertable {
    /**
     * 
     * @type {string}
     * @memberof PersonInsertable
     */
    name: string;
    /**
     * 
     * @type {Array<ContactInsertable>}
     * @memberof PersonInsertable
     */
    contacts: Array<ContactInsertable>;
}
/**
 * 
 * @export
 * @interface PersonUpdatable
 */
export interface PersonUpdatable {
    /**
     * 
     * @type {string}
     * @memberof PersonUpdatable
     */
    name?: string;
    /**
     * 
     * @type {Array<ContactUpdatable>}
     * @memberof PersonUpdatable
     */
    contacts: Array<ContactUpdatable>;
}
/**
 * 
 * @export
 * @interface Phase
 */
export interface Phase {
    /**
     * 
     * @type {number}
     * @memberof Phase
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Phase
     */
    name: string;
}
/**
 * 
 * @export
 * @interface PhaseInsertable
 */
export interface PhaseInsertable {
    /**
     * 
     * @type {string}
     * @memberof PhaseInsertable
     */
    name: string;
}
/**
 * 
 * @export
 * @interface PhaseJoinable
 */
export interface PhaseJoinable {
    /**
     * 
     * @type {number}
     * @memberof PhaseJoinable
     */
    id: number;
}
/**
 * 
 * @export
 * @interface RefreshRequest
 */
export interface RefreshRequest {
    /**
     * 
     * @type {string}
     * @memberof RefreshRequest
     */
    refreshToken: string;
}
/**
 * 
 * @export
 * @interface RefreshResponse
 */
export interface RefreshResponse {
    /**
     * 
     * @type {string}
     * @memberof RefreshResponse
     */
    accessToken: string;
}
/**
 * 
 * @export
 * @interface RefreshToken
 */
export interface RefreshToken {
    /**
     * 
     * @type {number}
     * @memberof RefreshToken
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof RefreshToken
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof RefreshToken
     */
    ip: string;
    /**
     * 
     * @type {Metadata}
     * @memberof RefreshToken
     */
    metadata: Metadata;
    /**
     * 
     * @type {User}
     * @memberof RefreshToken
     */
    user: User;
}
/**
 * 
 * @export
 * @interface RefreshTokenPayload
 */
export interface RefreshTokenPayload {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenPayload
     */
    type: Type;
    /**
     * 
     * @type {User}
     * @memberof RefreshTokenPayload
     */
    user: User;
    /**
     * 
     * @type {number}
     * @memberof RefreshTokenPayload
     */
    iat?: number;
    /**
     * 
     * @type {number}
     * @memberof RefreshTokenPayload
     */
    exp?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof RefreshTokenPayload
     */
    scopes?: Array<Scopes>;
}

/**
    * @export
    * @enum {string}
    */
export enum Type {
    ACCESS = 'access',
    REFRESH = 'refresh'
}
/**
    * @export
    * @enum {string}
    */
export enum Scopes {
    USERS_READ = 'users_read',
    USERS_WRITE = 'users_write',
    FINANCES_READ = 'finances_read',
    FINANCES_WRITE = 'finances_write',
    CONTRACTS_READ = 'contracts_read',
    CONTRACTS_WRITE = 'contracts_write'
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id: number;
    /**
     * 
     * @type {Person}
     * @memberof User
     */
    person: Person;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    username: string;
    /**
     * 
     * @type {any}
     * @memberof User
     */
    avatar: any;
    /**
     * 
     * @type {Array<WorkLog>}
     * @memberof User
     */
    workLogs: Array<WorkLog>;
    /**
     * 
     * @type {Array<Group>}
     * @memberof User
     */
    groups: Array<Group>;
}
/**
 * 
 * @export
 * @interface UserInsertable
 */
export interface UserInsertable {
    /**
     * 
     * @type {string}
     * @memberof UserInsertable
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof UserInsertable
     */
    password: string;
    /**
     * 
     * @type {PersonInsertable}
     * @memberof UserInsertable
     */
    person: PersonInsertable;
    /**
     * 
     * @type {FileJoinable}
     * @memberof UserInsertable
     */
    avatar?: FileJoinable;
    /**
     * 
     * @type {Array<GroupJoinable>}
     * @memberof UserInsertable
     */
    groups?: Array<GroupJoinable>;
}
/**
 * 
 * @export
 * @interface UserJoinable
 */
export interface UserJoinable {
    /**
     * 
     * @type {string}
     * @memberof UserJoinable
     */
    id: string;
}
/**
 * 
 * @export
 * @interface UserUpdatable
 */
export interface UserUpdatable {
    /**
     * 
     * @type {PersonUpdatable}
     * @memberof UserUpdatable
     */
    person?: PersonUpdatable;
    /**
     * 
     * @type {string}
     * @memberof UserUpdatable
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdatable
     */
    password?: string;
    /**
     * 
     * @type {FileJoinable}
     * @memberof UserUpdatable
     */
    avatar?: FileJoinable;
    /**
     * 
     * @type {Array<GroupJoinable>}
     * @memberof UserUpdatable
     */
    groups?: Array<GroupJoinable>;
}
/**
 * 
 * @export
 * @interface WorkLog
 */
export interface WorkLog {
    /**
     * 
     * @type {number}
     * @memberof WorkLog
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof WorkLog
     */
    from: string;
    /**
     * 
     * @type {string}
     * @memberof WorkLog
     */
    to: string;
    /**
     * 
     * @type {string}
     * @memberof WorkLog
     */
    description: string;
    /**
     * 
     * @type {Metadata}
     * @memberof WorkLog
     */
    metadata: Metadata;
    /**
     * 
     * @type {User}
     * @memberof WorkLog
     */
    user: User;
}
/**
 * 
 * @export
 * @interface WorkLogInsertable
 */
export interface WorkLogInsertable {
    /**
     * 
     * @type {string}
     * @memberof WorkLogInsertable
     */
    from: string;
    /**
     * 
     * @type {string}
     * @memberof WorkLogInsertable
     */
    to: string;
    /**
     * 
     * @type {string}
     * @memberof WorkLogInsertable
     */
    description?: string;
    /**
     * 
     * @type {UserJoinable}
     * @memberof WorkLogInsertable
     */
    user: UserJoinable;
    /**
     * 
     * @type {ContractJoinable}
     * @memberof WorkLogInsertable
     */
    contract?: ContractJoinable;
}
/**
 * 
 * @export
 * @interface WorkLogsQueryParams
 */
export interface WorkLogsQueryParams {
    /**
     * 
     * @type {string}
     * @memberof WorkLogsQueryParams
     */
    contract_code?: string;
    /**
     * 
     * @type {number}
     * @memberof WorkLogsQueryParams
     */
    contract_id?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkLogsQueryParams
     */
    user_username?: string;
    /**
     * 
     * @type {number}
     * @memberof WorkLogsQueryParams
     */
    user_id?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkLogsQueryParams
     */
    from?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkLogsQueryParams
     */
    to?: string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Login
         * @param {LoginRequest} [loginRequest] LoginRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest?: LoginRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh token
         * @param {RefreshRequest} [refreshRequest] RefreshRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (refreshRequest?: RefreshRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Login
         * @param {LoginRequest} [loginRequest] LoginRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest?: LoginRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Refresh token
         * @param {RefreshRequest} [refreshRequest] RefreshRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(refreshRequest?: RefreshRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(refreshRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Login
         * @param {LoginRequest} [loginRequest] LoginRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest?: LoginRequest, options?: any): AxiosPromise<LoginResponse> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh token
         * @param {RefreshRequest} [refreshRequest] RefreshRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(refreshRequest?: RefreshRequest, options?: any): AxiosPromise<RefreshResponse> {
            return localVarFp.refreshToken(refreshRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Login
     * @param {LoginRequest} [loginRequest] LoginRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(loginRequest?: LoginRequest, options?: any) {
        return AuthApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh token
     * @param {RefreshRequest} [refreshRequest] RefreshRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refreshToken(refreshRequest?: RefreshRequest, options?: any) {
        return AuthApiFp(this.configuration).refreshToken(refreshRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContractAttachmentsApi - axios parameter creator
 * @export
 */
export const ContractAttachmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create contract attachment
         * @param {string} code 
         * @param {ContractAttachmentInsertable} [contractAttachmentInsertable] ContractAttachmentInsertable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContractAttachment: async (code: string, contractAttachmentInsertable?: ContractAttachmentInsertable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('createContractAttachment', 'code', code)
            const localVarPath = `/api/contracts/{code}/attachments`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contractAttachmentInsertable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractAttachmentsApi - functional programming interface
 * @export
 */
export const ContractAttachmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContractAttachmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create contract attachment
         * @param {string} code 
         * @param {ContractAttachmentInsertable} [contractAttachmentInsertable] ContractAttachmentInsertable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContractAttachment(code: string, contractAttachmentInsertable?: ContractAttachmentInsertable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractAttachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContractAttachment(code, contractAttachmentInsertable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContractAttachmentsApi - factory interface
 * @export
 */
export const ContractAttachmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContractAttachmentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create contract attachment
         * @param {string} code 
         * @param {ContractAttachmentInsertable} [contractAttachmentInsertable] ContractAttachmentInsertable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContractAttachment(code: string, contractAttachmentInsertable?: ContractAttachmentInsertable, options?: any): AxiosPromise<ContractAttachment> {
            return localVarFp.createContractAttachment(code, contractAttachmentInsertable, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContractAttachmentsApi - object-oriented interface
 * @export
 * @class ContractAttachmentsApi
 * @extends {BaseAPI}
 */
export class ContractAttachmentsApi extends BaseAPI {
    /**
     * 
     * @summary Create contract attachment
     * @param {string} code 
     * @param {ContractAttachmentInsertable} [contractAttachmentInsertable] ContractAttachmentInsertable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractAttachmentsApi
     */
    public createContractAttachment(code: string, contractAttachmentInsertable?: ContractAttachmentInsertable, options?: any) {
        return ContractAttachmentsApiFp(this.configuration).createContractAttachment(code, contractAttachmentInsertable, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContractPhasesApi - axios parameter creator
 * @export
 */
export const ContractPhasesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Edit contract phases
         * @param {string} code 
         * @param {Array<ContractPhaseInsertable>} [contractPhaseInsertable] ContractPhaseInsertable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContractPhases: async (code: string, contractPhaseInsertable?: Array<ContractPhaseInsertable>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('editContractPhases', 'code', code)
            const localVarPath = `/api/contracts/{code}/phases`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contractPhaseInsertable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove contract phase
         * @param {string} code 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeContractPhase: async (code: string, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('removeContractPhase', 'code', code)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeContractPhase', 'id', id)
            const localVarPath = `/api/contracts/{code}/phases/{id}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractPhasesApi - functional programming interface
 * @export
 */
export const ContractPhasesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContractPhasesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Edit contract phases
         * @param {string} code 
         * @param {Array<ContractPhaseInsertable>} [contractPhaseInsertable] ContractPhaseInsertable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editContractPhases(code: string, contractPhaseInsertable?: Array<ContractPhaseInsertable>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContractPhase>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editContractPhases(code, contractPhaseInsertable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove contract phase
         * @param {string} code 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeContractPhase(code: string, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeContractPhase(code, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContractPhasesApi - factory interface
 * @export
 */
export const ContractPhasesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContractPhasesApiFp(configuration)
    return {
        /**
         * 
         * @summary Edit contract phases
         * @param {string} code 
         * @param {Array<ContractPhaseInsertable>} [contractPhaseInsertable] ContractPhaseInsertable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContractPhases(code: string, contractPhaseInsertable?: Array<ContractPhaseInsertable>, options?: any): AxiosPromise<Array<ContractPhase>> {
            return localVarFp.editContractPhases(code, contractPhaseInsertable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove contract phase
         * @param {string} code 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeContractPhase(code: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.removeContractPhase(code, id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContractPhasesApi - object-oriented interface
 * @export
 * @class ContractPhasesApi
 * @extends {BaseAPI}
 */
export class ContractPhasesApi extends BaseAPI {
    /**
     * 
     * @summary Edit contract phases
     * @param {string} code 
     * @param {Array<ContractPhaseInsertable>} [contractPhaseInsertable] ContractPhaseInsertable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractPhasesApi
     */
    public editContractPhases(code: string, contractPhaseInsertable?: Array<ContractPhaseInsertable>, options?: any) {
        return ContractPhasesApiFp(this.configuration).editContractPhases(code, contractPhaseInsertable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove contract phase
     * @param {string} code 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractPhasesApi
     */
    public removeContractPhase(code: string, id: number, options?: any) {
        return ContractPhasesApiFp(this.configuration).removeContractPhase(code, id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContractsApi - axios parameter creator
 * @export
 */
export const ContractsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create contract
         * @param {ContractInsertable} [contractInsertable] ContractInsertable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContract: async (contractInsertable?: ContractInsertable, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contractInsertable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete contract by code
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContractByCode: async (code: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('deleteContractByCode', 'code', code)
            const localVarPath = `/api/contracts/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit contract
         * @param {string} code 
         * @param {ContractUpdatable} [contractUpdatable] ContractUpdatable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContract: async (code: string, contractUpdatable?: ContractUpdatable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('editContract', 'code', code)
            const localVarPath = `/api/contracts/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contractUpdatable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all contracts
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {string} [orderBy] 
         * @param {'ASC' | 'DESC'} [order] 
         * @param {ContractsQueryFilterable} [filterMax] 
         * @param {ContractsQueryFilterable} [filterMin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContracts: async (limit?: number, page?: number, search?: string, orderBy?: string, order?: 'ASC' | 'DESC', filterMax?: ContractsQueryFilterable, filterMin?: ContractsQueryFilterable, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (filterMax !== undefined) {
                localVarQueryParameter['filterMax'] = filterMax;
            }

            if (filterMin !== undefined) {
                localVarQueryParameter['filterMin'] = filterMin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get contract by code
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractByCode: async (code: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('getContractByCode', 'code', code)
            const localVarPath = `/api/contracts/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractsApi - functional programming interface
 * @export
 */
export const ContractsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContractsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create contract
         * @param {ContractInsertable} [contractInsertable] ContractInsertable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContract(contractInsertable?: ContractInsertable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContract(contractInsertable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete contract by code
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContractByCode(code: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContractByCode(code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit contract
         * @param {string} code 
         * @param {ContractUpdatable} [contractUpdatable] ContractUpdatable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editContract(code: string, contractUpdatable?: ContractUpdatable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editContract(code, contractUpdatable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all contracts
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {string} [orderBy] 
         * @param {'ASC' | 'DESC'} [order] 
         * @param {ContractsQueryFilterable} [filterMax] 
         * @param {ContractsQueryFilterable} [filterMin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllContracts(limit?: number, page?: number, search?: string, orderBy?: string, order?: 'ASC' | 'DESC', filterMax?: ContractsQueryFilterable, filterMin?: ContractsQueryFilterable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Contract>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllContracts(limit, page, search, orderBy, order, filterMax, filterMin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get contract by code
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractByCode(code: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractByCode(code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContractsApi - factory interface
 * @export
 */
export const ContractsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContractsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create contract
         * @param {ContractInsertable} [contractInsertable] ContractInsertable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContract(contractInsertable?: ContractInsertable, options?: any): AxiosPromise<Contract> {
            return localVarFp.createContract(contractInsertable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete contract by code
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContractByCode(code: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteContractByCode(code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit contract
         * @param {string} code 
         * @param {ContractUpdatable} [contractUpdatable] ContractUpdatable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContract(code: string, contractUpdatable?: ContractUpdatable, options?: any): AxiosPromise<Contract> {
            return localVarFp.editContract(code, contractUpdatable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all contracts
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {string} [orderBy] 
         * @param {'ASC' | 'DESC'} [order] 
         * @param {ContractsQueryFilterable} [filterMax] 
         * @param {ContractsQueryFilterable} [filterMin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContracts(limit?: number, page?: number, search?: string, orderBy?: string, order?: 'ASC' | 'DESC', filterMax?: ContractsQueryFilterable, filterMin?: ContractsQueryFilterable, options?: any): AxiosPromise<Array<Contract>> {
            return localVarFp.getAllContracts(limit, page, search, orderBy, order, filterMax, filterMin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get contract by code
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractByCode(code: string, options?: any): AxiosPromise<Contract> {
            return localVarFp.getContractByCode(code, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContractsApi - object-oriented interface
 * @export
 * @class ContractsApi
 * @extends {BaseAPI}
 */
export class ContractsApi extends BaseAPI {
    /**
     * 
     * @summary Create contract
     * @param {ContractInsertable} [contractInsertable] ContractInsertable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public createContract(contractInsertable?: ContractInsertable, options?: any) {
        return ContractsApiFp(this.configuration).createContract(contractInsertable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete contract by code
     * @param {string} code 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public deleteContractByCode(code: string, options?: any) {
        return ContractsApiFp(this.configuration).deleteContractByCode(code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit contract
     * @param {string} code 
     * @param {ContractUpdatable} [contractUpdatable] ContractUpdatable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public editContract(code: string, contractUpdatable?: ContractUpdatable, options?: any) {
        return ContractsApiFp(this.configuration).editContract(code, contractUpdatable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all contracts
     * @param {number} [limit] 
     * @param {number} [page] 
     * @param {string} [search] 
     * @param {string} [orderBy] 
     * @param {'ASC' | 'DESC'} [order] 
     * @param {ContractsQueryFilterable} [filterMax] 
     * @param {ContractsQueryFilterable} [filterMin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public getAllContracts(limit?: number, page?: number, search?: string, orderBy?: string, order?: 'ASC' | 'DESC', filterMax?: ContractsQueryFilterable, filterMin?: ContractsQueryFilterable, options?: any) {
        return ContractsApiFp(this.configuration).getAllContracts(limit, page, search, orderBy, order, filterMax, filterMin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get contract by code
     * @param {string} code 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public getContractByCode(code: string, options?: any) {
        return ContractsApiFp(this.configuration).getContractByCode(code, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomersApi - axios parameter creator
 * @export
 */
export const CustomersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create customer
         * @param {CustomerInsertable} [customerInsertable] CustomerInsertable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer: async (customerInsertable?: CustomerInsertable, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerInsertable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCustomers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get customer by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerById: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCustomerById', 'id', id)
            const localVarPath = `/api/customers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomersApi - functional programming interface
 * @export
 */
export const CustomersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create customer
         * @param {CustomerInsertable} [customerInsertable] CustomerInsertable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomer(customerInsertable?: CustomerInsertable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerInsertable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomer(customerInsertable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCustomers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Customer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCustomers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get customer by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerById(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomerById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomersApi - factory interface
 * @export
 */
export const CustomersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create customer
         * @param {CustomerInsertable} [customerInsertable] CustomerInsertable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer(customerInsertable?: CustomerInsertable, options?: any): AxiosPromise<CustomerInsertable> {
            return localVarFp.createCustomer(customerInsertable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCustomers(options?: any): AxiosPromise<Array<Customer>> {
            return localVarFp.getAllCustomers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get customer by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerById(id: number, options?: any): AxiosPromise<Customer> {
            return localVarFp.getCustomerById(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomersApi - object-oriented interface
 * @export
 * @class CustomersApi
 * @extends {BaseAPI}
 */
export class CustomersApi extends BaseAPI {
    /**
     * 
     * @summary Create customer
     * @param {CustomerInsertable} [customerInsertable] CustomerInsertable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public createCustomer(customerInsertable?: CustomerInsertable, options?: any) {
        return CustomersApiFp(this.configuration).createCustomer(customerInsertable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all customers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getAllCustomers(options?: any) {
        return CustomersApiFp(this.configuration).getAllCustomers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get customer by id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getCustomerById(id: number, options?: any) {
        return CustomersApiFp(this.configuration).getCustomerById(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get file by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileById: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFileById', 'id', id)
            const localVarPath = `/api/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload file
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (file?: any, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get file by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileById(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload file
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get file by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileById(id: number, options?: any): AxiosPromise<ModelFile> {
            return localVarFp.getFileById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload file
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(file?: any, options?: any): AxiosPromise<ModelFile> {
            return localVarFp.uploadFile(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * 
     * @summary Get file by id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFileById(id: number, options?: any) {
        return FilesApiFp(this.configuration).getFileById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload file
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public uploadFile(file?: any, options?: any) {
        return FilesApiFp(this.configuration).uploadFile(file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create group
         * @param {GroupInsertable} [groupInsertable] GroupInsertable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (groupInsertable?: GroupInsertable, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupInsertable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete group by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupById: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteGroupById', 'id', id)
            const localVarPath = `/api/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGroups: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get group by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupById: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGroupById', 'id', id)
            const localVarPath = `/api/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create group
         * @param {GroupInsertable} [groupInsertable] GroupInsertable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(groupInsertable?: GroupInsertable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(groupInsertable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete group by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroupById(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroupById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllGroups(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Group>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get group by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupById(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create group
         * @param {GroupInsertable} [groupInsertable] GroupInsertable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(groupInsertable?: GroupInsertable, options?: any): AxiosPromise<Group> {
            return localVarFp.createGroup(groupInsertable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete group by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupById(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroupById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGroups(options?: any): AxiosPromise<Array<Group>> {
            return localVarFp.getAllGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get group by id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupById(id: number, options?: any): AxiosPromise<Group> {
            return localVarFp.getGroupById(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * 
     * @summary Create group
     * @param {GroupInsertable} [groupInsertable] GroupInsertable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public createGroup(groupInsertable?: GroupInsertable, options?: any) {
        return GroupsApiFp(this.configuration).createGroup(groupInsertable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete group by id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteGroupById(id: number, options?: any) {
        return GroupsApiFp(this.configuration).deleteGroupById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getAllGroups(options?: any) {
        return GroupsApiFp(this.configuration).getAllGroups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get group by id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupById(id: number, options?: any) {
        return GroupsApiFp(this.configuration).getGroupById(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OpenAPIDocsApi - axios parameter creator
 * @export
 */
export const OpenAPIDocsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Serve docs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serveDocs: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/openapi-docs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Serve spec
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serveSpec: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/openapi-docs/openapi3.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OpenAPIDocsApi - functional programming interface
 * @export
 */
export const OpenAPIDocsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OpenAPIDocsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Serve docs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serveDocs(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serveDocs(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Serve spec
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serveSpec(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serveSpec(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OpenAPIDocsApi - factory interface
 * @export
 */
export const OpenAPIDocsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OpenAPIDocsApiFp(configuration)
    return {
        /**
         * 
         * @summary Serve docs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serveDocs(options?: any): AxiosPromise<void> {
            return localVarFp.serveDocs(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Serve spec
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serveSpec(options?: any): AxiosPromise<void> {
            return localVarFp.serveSpec(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OpenAPIDocsApi - object-oriented interface
 * @export
 * @class OpenAPIDocsApi
 * @extends {BaseAPI}
 */
export class OpenAPIDocsApi extends BaseAPI {
    /**
     * 
     * @summary Serve docs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAPIDocsApi
     */
    public serveDocs(options?: any) {
        return OpenAPIDocsApiFp(this.configuration).serveDocs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Serve spec
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAPIDocsApi
     */
    public serveSpec(options?: any) {
        return OpenAPIDocsApiFp(this.configuration).serveSpec(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PeopleApi - axios parameter creator
 * @export
 */
export const PeopleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create contact
         * @param {number} personId 
         * @param {ContactInsertable} [contactInsertable] ContactInsertable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContact: async (personId: number, contactInsertable?: ContactInsertable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('createContact', 'personId', personId)
            const localVarPath = `/api/people/{personId}`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactInsertable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete contact
         * @param {number} personId 
         * @param {number} contactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContact: async (personId: number, contactId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('deleteContact', 'personId', personId)
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('deleteContact', 'contactId', contactId)
            const localVarPath = `/api/people/{personId}/{contactId}`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)))
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit contact
         * @param {number} personId 
         * @param {number} contactId 
         * @param {ContactUpdatable} [contactUpdatable] ContactUpdatable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContact: async (personId: number, contactId: number, contactUpdatable?: ContactUpdatable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('editContact', 'personId', personId)
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('editContact', 'contactId', contactId)
            const localVarPath = `/api/people/{personId}/{contactId}`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)))
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactUpdatable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit person
         * @param {number} personId 
         * @param {PersonUpdatable} [personUpdatable] PersonUpdatable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPerson: async (personId: number, personUpdatable?: PersonUpdatable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('editPerson', 'personId', personId)
            const localVarPath = `/api/people/{personId}`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personUpdatable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PeopleApi - functional programming interface
 * @export
 */
export const PeopleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PeopleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create contact
         * @param {number} personId 
         * @param {ContactInsertable} [contactInsertable] ContactInsertable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContact(personId: number, contactInsertable?: ContactInsertable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contact>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContact(personId, contactInsertable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete contact
         * @param {number} personId 
         * @param {number} contactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContact(personId: number, contactId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContact(personId, contactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit contact
         * @param {number} personId 
         * @param {number} contactId 
         * @param {ContactUpdatable} [contactUpdatable] ContactUpdatable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editContact(personId: number, contactId: number, contactUpdatable?: ContactUpdatable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contact>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editContact(personId, contactId, contactUpdatable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit person
         * @param {number} personId 
         * @param {PersonUpdatable} [personUpdatable] PersonUpdatable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editPerson(personId: number, personUpdatable?: PersonUpdatable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Person>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editPerson(personId, personUpdatable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PeopleApi - factory interface
 * @export
 */
export const PeopleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PeopleApiFp(configuration)
    return {
        /**
         * 
         * @summary Create contact
         * @param {number} personId 
         * @param {ContactInsertable} [contactInsertable] ContactInsertable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContact(personId: number, contactInsertable?: ContactInsertable, options?: any): AxiosPromise<Contact> {
            return localVarFp.createContact(personId, contactInsertable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete contact
         * @param {number} personId 
         * @param {number} contactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContact(personId: number, contactId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteContact(personId, contactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit contact
         * @param {number} personId 
         * @param {number} contactId 
         * @param {ContactUpdatable} [contactUpdatable] ContactUpdatable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editContact(personId: number, contactId: number, contactUpdatable?: ContactUpdatable, options?: any): AxiosPromise<Contact> {
            return localVarFp.editContact(personId, contactId, contactUpdatable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit person
         * @param {number} personId 
         * @param {PersonUpdatable} [personUpdatable] PersonUpdatable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editPerson(personId: number, personUpdatable?: PersonUpdatable, options?: any): AxiosPromise<Person> {
            return localVarFp.editPerson(personId, personUpdatable, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PeopleApi - object-oriented interface
 * @export
 * @class PeopleApi
 * @extends {BaseAPI}
 */
export class PeopleApi extends BaseAPI {
    /**
     * 
     * @summary Create contact
     * @param {number} personId 
     * @param {ContactInsertable} [contactInsertable] ContactInsertable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    public createContact(personId: number, contactInsertable?: ContactInsertable, options?: any) {
        return PeopleApiFp(this.configuration).createContact(personId, contactInsertable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete contact
     * @param {number} personId 
     * @param {number} contactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    public deleteContact(personId: number, contactId: number, options?: any) {
        return PeopleApiFp(this.configuration).deleteContact(personId, contactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit contact
     * @param {number} personId 
     * @param {number} contactId 
     * @param {ContactUpdatable} [contactUpdatable] ContactUpdatable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    public editContact(personId: number, contactId: number, contactUpdatable?: ContactUpdatable, options?: any) {
        return PeopleApiFp(this.configuration).editContact(personId, contactId, contactUpdatable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit person
     * @param {number} personId 
     * @param {PersonUpdatable} [personUpdatable] PersonUpdatable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    public editPerson(personId: number, personUpdatable?: PersonUpdatable, options?: any) {
        return PeopleApiFp(this.configuration).editPerson(personId, personUpdatable, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PhasesApi - axios parameter creator
 * @export
 */
export const PhasesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create phase
         * @param {PhaseInsertable} [phaseInsertable] PhaseInsertable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPhase: async (phaseInsertable?: PhaseInsertable, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/phases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(phaseInsertable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all phases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPhases: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/phases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PhasesApi - functional programming interface
 * @export
 */
export const PhasesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PhasesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create phase
         * @param {PhaseInsertable} [phaseInsertable] PhaseInsertable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPhase(phaseInsertable?: PhaseInsertable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Phase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPhase(phaseInsertable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all phases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPhases(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Phase>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPhases(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PhasesApi - factory interface
 * @export
 */
export const PhasesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PhasesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create phase
         * @param {PhaseInsertable} [phaseInsertable] PhaseInsertable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPhase(phaseInsertable?: PhaseInsertable, options?: any): AxiosPromise<Phase> {
            return localVarFp.createPhase(phaseInsertable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all phases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPhases(options?: any): AxiosPromise<Array<Phase>> {
            return localVarFp.getAllPhases(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PhasesApi - object-oriented interface
 * @export
 * @class PhasesApi
 * @extends {BaseAPI}
 */
export class PhasesApi extends BaseAPI {
    /**
     * 
     * @summary Create phase
     * @param {PhaseInsertable} [phaseInsertable] PhaseInsertable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhasesApi
     */
    public createPhase(phaseInsertable?: PhaseInsertable, options?: any) {
        return PhasesApiFp(this.configuration).createPhase(phaseInsertable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all phases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhasesApi
     */
    public getAllPhases(options?: any) {
        return PhasesApiFp(this.configuration).getAllPhases(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create user
         * @param {UserInsertable} [userInsertable] UserInsertable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (userInsertable?: UserInsertable, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInsertable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete user by username
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserByUsername: async (username: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('deleteUserByUsername', 'username', username)
            const localVarPath = `/api/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit user
         * @param {string} username 
         * @param {UserUpdatable} [userUpdatable] UserUpdatable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUser: async (username: string, userUpdatable?: UserUpdatable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('editUser', 'username', username)
            const localVarPath = `/api/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdatable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user by username
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUsername: async (username: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getUserByUsername', 'username', username)
            const localVarPath = `/api/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create user
         * @param {UserInsertable} [userInsertable] UserInsertable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(userInsertable?: UserInsertable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(userInsertable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete user by username
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserByUsername(username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserByUsername(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit user
         * @param {string} username 
         * @param {UserUpdatable} [userUpdatable] UserUpdatable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editUser(username: string, userUpdatable?: UserUpdatable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editUser(username, userUpdatable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user by username
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByUsername(username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByUsername(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create user
         * @param {UserInsertable} [userInsertable] UserInsertable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(userInsertable?: UserInsertable, options?: any): AxiosPromise<User> {
            return localVarFp.createUser(userInsertable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete user by username
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserByUsername(username: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserByUsername(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit user
         * @param {string} username 
         * @param {UserUpdatable} [userUpdatable] UserUpdatable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUser(username: string, userUpdatable?: UserUpdatable, options?: any): AxiosPromise<User> {
            return localVarFp.editUser(username, userUpdatable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(options?: any): AxiosPromise<Array<User>> {
            return localVarFp.getAllUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user by username
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUsername(username: string, options?: any): AxiosPromise<User> {
            return localVarFp.getUserByUsername(username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Create user
     * @param {UserInsertable} [userInsertable] UserInsertable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(userInsertable?: UserInsertable, options?: any) {
        return UsersApiFp(this.configuration).createUser(userInsertable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete user by username
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUserByUsername(username: string, options?: any) {
        return UsersApiFp(this.configuration).deleteUserByUsername(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit user
     * @param {string} username 
     * @param {UserUpdatable} [userUpdatable] UserUpdatable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public editUser(username: string, userUpdatable?: UserUpdatable, options?: any) {
        return UsersApiFp(this.configuration).editUser(username, userUpdatable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getAllUsers(options?: any) {
        return UsersApiFp(this.configuration).getAllUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user by username
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserByUsername(username: string, options?: any) {
        return UsersApiFp(this.configuration).getUserByUsername(username, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkLogsApi - axios parameter creator
 * @export
 */
export const WorkLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create work log
         * @param {WorkLogInsertable} [workLogInsertable] WorkLogInsertable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkLog: async (workLogInsertable?: WorkLogInsertable, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/worklogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workLogInsertable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all work logs
         * @param {string} [contractCode] 
         * @param {number} [contractId] 
         * @param {string} [userUsername] 
         * @param {number} [userId] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWorkLogs: async (contractCode?: string, contractId?: number, userUsername?: string, userId?: number, from?: string, to?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/worklogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contractCode !== undefined) {
                localVarQueryParameter['contract.code'] = contractCode;
            }

            if (contractId !== undefined) {
                localVarQueryParameter['contract.id'] = contractId;
            }

            if (userUsername !== undefined) {
                localVarQueryParameter['user.username'] = userUsername;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user.id'] = userId;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkLogsApi - functional programming interface
 * @export
 */
export const WorkLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create work log
         * @param {WorkLogInsertable} [workLogInsertable] WorkLogInsertable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkLog(workLogInsertable?: WorkLogInsertable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkLogInsertable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkLog(workLogInsertable, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all work logs
         * @param {string} [contractCode] 
         * @param {number} [contractId] 
         * @param {string} [userUsername] 
         * @param {number} [userId] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllWorkLogs(contractCode?: string, contractId?: number, userUsername?: string, userId?: number, from?: string, to?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllWorkLogs(contractCode, contractId, userUsername, userId, from, to, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkLogsApi - factory interface
 * @export
 */
export const WorkLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkLogsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create work log
         * @param {WorkLogInsertable} [workLogInsertable] WorkLogInsertable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkLog(workLogInsertable?: WorkLogInsertable, options?: any): AxiosPromise<WorkLogInsertable> {
            return localVarFp.createWorkLog(workLogInsertable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all work logs
         * @param {string} [contractCode] 
         * @param {number} [contractId] 
         * @param {string} [userUsername] 
         * @param {number} [userId] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWorkLogs(contractCode?: string, contractId?: number, userUsername?: string, userId?: number, from?: string, to?: string, options?: any): AxiosPromise<Array<WorkLog>> {
            return localVarFp.getAllWorkLogs(contractCode, contractId, userUsername, userId, from, to, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkLogsApi - object-oriented interface
 * @export
 * @class WorkLogsApi
 * @extends {BaseAPI}
 */
export class WorkLogsApi extends BaseAPI {
    /**
     * 
     * @summary Create work log
     * @param {WorkLogInsertable} [workLogInsertable] WorkLogInsertable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkLogsApi
     */
    public createWorkLog(workLogInsertable?: WorkLogInsertable, options?: any) {
        return WorkLogsApiFp(this.configuration).createWorkLog(workLogInsertable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all work logs
     * @param {string} [contractCode] 
     * @param {number} [contractId] 
     * @param {string} [userUsername] 
     * @param {number} [userId] 
     * @param {string} [from] 
     * @param {string} [to] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkLogsApi
     */
    public getAllWorkLogs(contractCode?: string, contractId?: number, userUsername?: string, userId?: number, from?: string, to?: string, options?: any) {
        return WorkLogsApiFp(this.configuration).getAllWorkLogs(contractCode, contractId, userUsername, userId, from, to, options).then((request) => request(this.axios, this.basePath));
    }
}


